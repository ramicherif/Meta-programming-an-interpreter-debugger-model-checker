/*
 * generated by Xtext 2.14.0
 */
package fr.unice.polytech.si5.polycreate.concretesyntax.serializer;

import com.google.inject.Inject;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.CloseGripper;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.Comparison;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.GoBackward;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.GoForward;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.GripperSensor;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.LeftSensor;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.OpenGripper;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.Polycreate;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.PolycreatePackage;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.RightSensor;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.Stop;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.StructuralCondition;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.Turn;
import fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.Variable;
import fr.unice.polytech.si5.polycreate.concretesyntax.services.PolycreateGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;

@SuppressWarnings("all")
public class PolycreateSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PolycreateGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PolycreatePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PolycreatePackage.CLOSE_GRIPPER:
				sequence_CloseGripper(context, (CloseGripper) semanticObject); 
				return; 
			case PolycreatePackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case PolycreatePackage.GO_BACKWARD:
				sequence_GoBackward(context, (GoBackward) semanticObject); 
				return; 
			case PolycreatePackage.GO_FORWARD:
				sequence_GoForward(context, (GoForward) semanticObject); 
				return; 
			case PolycreatePackage.GRIPPER_SENSOR:
				sequence_GripperSensor(context, (GripperSensor) semanticObject); 
				return; 
			case PolycreatePackage.LEFT_SENSOR:
				sequence_LeftSensor(context, (LeftSensor) semanticObject); 
				return; 
			case PolycreatePackage.OBJECT:
				sequence_Object(context, (fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.Object) semanticObject); 
				return; 
			case PolycreatePackage.OPEN_GRIPPER:
				sequence_OpenGripper(context, (OpenGripper) semanticObject); 
				return; 
			case PolycreatePackage.POLYCREATE:
				sequence_Polycreate(context, (Polycreate) semanticObject); 
				return; 
			case PolycreatePackage.RIGHT_SENSOR:
				sequence_RightSensor(context, (RightSensor) semanticObject); 
				return; 
			case PolycreatePackage.STOP:
				sequence_Stop(context, (Stop) semanticObject); 
				return; 
			case PolycreatePackage.STRUCTURAL_CONDITION:
				sequence_StructuralCondition(context, (StructuralCondition) semanticObject); 
				return; 
			case PolycreatePackage.TURN:
				sequence_Turn(context, (Turn) semanticObject); 
				return; 
			case PolycreatePackage.VARIABLE:
				sequence_Variable_Impl(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Operation returns CloseGripper
	 *     CloseGripper returns CloseGripper
	 *
	 * Constraint:
	 *     {CloseGripper}
	 */
	protected void sequence_CloseGripper(ISerializationContext context, CloseGripper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Comparison
	 *     Comparison returns Comparison
	 *
	 * Constraint:
	 *     (value=VarType? leftVariable=[Variable|EString] rightVariable=[Variable|EString])
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns GoBackward
	 *     GoBackward returns GoBackward
	 *
	 * Constraint:
	 *     {GoBackward}
	 */
	protected void sequence_GoBackward(ISerializationContext context, GoBackward semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns GoForward
	 *     GoForward returns GoForward
	 *
	 * Constraint:
	 *     {GoForward}
	 */
	protected void sequence_GoForward(ISerializationContext context, GoForward semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns GripperSensor
	 *     GripperSensor returns GripperSensor
	 *
	 * Constraint:
	 *     (name=EString type=VarType? initialValue=EDouble?)
	 */
	protected void sequence_GripperSensor(ISerializationContext context, GripperSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns LeftSensor
	 *     LeftSensor returns LeftSensor
	 *
	 * Constraint:
	 *     (name=EString type=VarType? initialValue=EDouble?)
	 */
	protected void sequence_LeftSensor(ISerializationContext context, LeftSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Object
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (name=EString type=VarType? initialValue=EDouble? position=VarType?)
	 */
	protected void sequence_Object(ISerializationContext context, fr.unice.polytech.si5.polycreate.abstractsyntax.polycreate.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns OpenGripper
	 *     OpenGripper returns OpenGripper
	 *
	 * Constraint:
	 *     {OpenGripper}
	 */
	protected void sequence_OpenGripper(ISerializationContext context, OpenGripper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Polycreate returns Polycreate
	 *
	 * Constraint:
	 *     (name=EString (operation+=Operation operation+=Operation*)? (variable+=Variable variable+=Variable*)?)
	 */
	protected void sequence_Polycreate(ISerializationContext context, Polycreate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns RightSensor
	 *     RightSensor returns RightSensor
	 *
	 * Constraint:
	 *     (name=EString type=VarType? initialValue=EDouble?)
	 */
	protected void sequence_RightSensor(ISerializationContext context, RightSensor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Stop
	 *     Stop returns Stop
	 *
	 * Constraint:
	 *     {Stop}
	 */
	protected void sequence_Stop(ISerializationContext context, Stop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns StructuralCondition
	 *     StructuralCondition returns StructuralCondition
	 *
	 * Constraint:
	 *     (
	 *         (then+=[Operation|EString] then+=[Operation|EString]*)? 
	 *         (else+=[Operation|EString] else+=[Operation|EString]*)? 
	 *         if+=[Condition|EString] 
	 *         if+=[Condition|EString]*
	 *     )
	 */
	protected void sequence_StructuralCondition(ISerializationContext context, StructuralCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Turn
	 *     Turn returns Turn
	 *
	 * Constraint:
	 *     {Turn}
	 */
	protected void sequence_Turn(ISerializationContext context, Turn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *     Variable_Impl returns Variable
	 *
	 * Constraint:
	 *     (name=EString type=VarType? initialValue=EDouble?)
	 */
	protected void sequence_Variable_Impl(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
